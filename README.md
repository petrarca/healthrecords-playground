# HealthRecords Playground

## Overview

HealthRecords Playground is a showcase application demonstrating techniques for building a modern electronic health records (EHR) system. This application highlights how AI-assisted development can create sophisticated healthcare applications with minimal manual coding. Most components, including the complex ones like patient record visualization, natural language assistant, and context-aware navigation, were generated by AI.

The application serves as a demonstration of state-of-the-art frontend development practices, focusing on modularity, maintainability, and user experience.

> Note: Even this README documentation was mostly generated by AI, demonstrating how AI can assist with comprehensive documentation alongside code generation. Claude 3.5 / 3.7 Sonnet were primarily used for generating both the code and documentation in this project.

Despite being AI-generated, the codebase maintains high quality standards and has passed various quality gates including type checking, linting, and code style consistency checks. This demonstrates how AI-assisted development can produce production-ready code that adheres to best practices.

The application also adheres to accessibility standards through proper implementation of ARIA (Accessible Rich Internet Applications) attributes and patterns, ensuring the interface is usable by people with disabilities who use assistive technologies. This commitment to accessibility reflects modern web development best practices and makes the application more inclusive for all users.

## Technology Stack

- **Frontend Framework**: React 19 with TypeScript
- **Routing**: React Router v7
- **State Management**: RxJS for reactive state management
- **UI Components**: Custom components built with Tailwind CSS
- **Backend**: Supabase (Database as a Service)
- **Build Tool**: Vite
- **Package Manager**: pnpm
- **Testing**: React Testing Library (for component tests)
- **Data Fetching**: TanStack Query (formerly known as React Query)

## Architecture

The application follows a modular architecture with clear separation of concerns:

### Core Components

1. **Context System**: Tracks current patient, view, and record context across the application
2. **Navigation Service**: Handles routing with context awareness
3. **Assistant Service**: Provides a natural language interface for interacting with the application
4. **Search Service**: Enables powerful patient and record search capabilities

### Architectural Principles

The application implements a clean separation between UI components and business logic:

- **UI Components**: Pure presentation layer focused on rendering and user interactions
  - Components receive data via props and emit events for user actions
  - Stateless where possible, with local state only for UI concerns
  - No direct data fetching or business logic within components

- **Services Layer**: Encapsulates all business logic and data operations
  - Services are singleton classes that manage specific domains of functionality
  - Handle data fetching, transformation, and state management
  - Provide reactive streams of data that components can subscribe to
  - Abstract away implementation details from the UI layer

This separation ensures:
- Better testability of both UI and business logic in isolation
- Easier maintenance as changes to business logic don't require UI changes
- Improved reusability of both components and services
- Clear responsibilities and dependencies between application layers

### Key Directories

- `/src/components`: UI components organized by feature
- `/src/services`: Core application services
- `/src/context`: Application context management
- `/src/hooks`: Custom React hooks
- `/src/models`: Data models and interfaces
- `/src/lib`: Utility libraries and third-party integrations

### Notable Features

- **Natural Language Assistant**: Process commands like "show me patient records" or "search for patients with diabetes"
- **Patient Timeline**: View patient medical history in a chronological format
- **Context-Aware Navigation**: The application maintains awareness of the current patient and view
- **Responsive Design**: Works across desktop and mobile devices

### Advanced Architecture Features

#### Flexible Metadata System

The application implements a sophisticated metadata system for medical records:

- **Field Metadata**: Each field in a medical record has associated metadata that describes its type, validation rules, and rendering preferences
- **Type-Safe Definitions**: TypeScript interfaces ensure consistency and type safety across the application
- **Quantity Value Handling**: Special handling for medical measurements with units (e.g., blood pressure, temperature)
- **Validation Rules**: Built-in validation based on field metadata

#### Plugin-Based Field Rendering

A modular system for rendering different types of medical data:

- **Renderer Registry**: Dynamically register and use custom field renderers
- **Metadata-Driven**: Field metadata specifies which renderer to use for each field
- **Built-in Renderers**: Includes specialized renderers for common medical data types:
  - **Lab Components Renderer**: Displays laboratory results in a tabular format
  - **JSON Renderer**: Interactive, collapsible view for complex JSON data
- **Extensibility**: Easily add new renderers without modifying existing code

Visit the demo routes (`#/demo/json-renderer` and `#/demo/field-renderers`) to see these systems in action.

## Development Setup

### Prerequisites

- Node.js (v18 or later)
- pnpm (v8 or later)
- Supabase account (for database)

### Supabase Setup

1. Create a new Supabase project at [https://supabase.com](https://supabase.com)
2. Once your project is created, navigate to the SQL Editor in the Supabase dashboard
3. Execute the database schema:
   - Open the `db/schema.sql` file from this repository
   - Copy the contents and paste them into the SQL Editor
   - Run the query to create all necessary tables and functions
4. Load the test data:
   - Open the `db/test_data.sql` file from this repository
   - Copy the contents and paste them into the SQL Editor
   - Run the query to populate the database with sample patients and medical records
5. Get your Supabase URL and anon key:
   - Go to Project Settings > API
   - Copy the URL and anon key for the next step

### Environment Configuration

Create a `.env` file in the root directory with the following variables:

```
VITE_SUPABASE_URL=your_supabase_url
VITE_SUPABASE_ANON_KEY=your_supabase_anon_key
```

### Installation

```bash
# Install dependencies
pnpm install

# Start development server
pnpm dev
```

### Building for Production

```bash
# Type check and build
pnpm build

# Preview production build
pnpm preview
```

### Linting

The project uses ESLint with TypeScript-ESLint for code quality and consistency. To lint the project:

```bash
# Run ESLint on the entire codebase
pnpm lint
```

The ESLint configuration is defined in `eslint.config.js` and includes:
- TypeScript-specific rules
- React Hooks linting
- React Refresh plugin

Husky is configured to run linting before commits to ensure code quality.

## Project Structure

```
healthrecords-playground/
├── db/                  # Database schema and migrations
├── public/              # Static assets
├── scripts/             # Utility scripts
├── src/
│   ├── assets/          # Application assets
│   ├── components/      # React components
│   │   ├── patient/     # Patient-related components
│   │   │   ├── demographics/  # Patient demographic information
│   │   │   └── vitals/  # Vital signs components and charts
│   │   ├── timeline/    # Timeline view components
│   │   └── ui/          # Reusable UI components
│   │       └── fieldRenderers/  # Custom field rendering components
│   ├── constants/       # Application constants
│   ├── context/         # Context providers
│   ├── hooks/           # Custom React hooks
│   ├── lib/             # Third-party library integrations
│   ├── models/          # Data models
│   ├── services/        # Application services
│   │   ├── assistant/   # Natural language assistant
│   │   │   └── intents/ # Intent handlers for assistant
│   │   ├── mappers/     # Data mappers
│   │   └── search/      # Search functionality
│   ├── styles/          # Global styles
│   ├── types/           # TypeScript type definitions
│   └── utils/           # Utility functions
└── vite.config.ts       # Vite configuration
```

## Contributing

This is a showcase project primarily for demonstration purposes. However, if you'd like to experiment with it:

1. Fork the repository
2. Create a feature branch
3. Submit a pull request

## License

[MIT License](LICENSE)
